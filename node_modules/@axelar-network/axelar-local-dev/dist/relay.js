'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.relay = exports.gasLogsWithToken = exports.gasLogs = void 0;
var ethers_1 = require("ethers");
var _a = ethers_1.ethers.utils, defaultAbiCoder = _a.defaultAbiCoder, arrayify = _a.arrayify, keccak256 = _a.keccak256, id = _a.id, solidityPack = _a.solidityPack, toUtf8Bytes = _a.toUtf8Bytes;
var AddressZero = ethers_1.ethers.constants.AddressZero;
var utils_1 = require("./utils");
var Network_1 = require("./Network");
var networkUtils_1 = require("./networkUtils");
//An internal class for handling axelar commands.
var Command = /** @class */ (function () {
    function Command(commandId, name, data, dataSignature, post) {
        if (post === void 0) { post = undefined; }
        this.commandId = commandId;
        this.name = name;
        this.data = data;
        this.encodedData = defaultAbiCoder.encode(dataSignature, data);
        this.post = post;
    }
    return Command;
}());
// Constants used in the encironment to relay
exports.gasLogs = [];
exports.gasLogsWithToken = [];
var IAxelarExecutable = require('../artifacts/@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarExecutable.sol/IAxelarExecutable.json');
var ROLE_OWNER = 1;
var getAliasFromSymbol = function (tokens, symbol) {
    for (var alias in tokens) {
        if (tokens[alias] == symbol)
            return alias;
    }
    return '';
};
var updateGasLogs = function (from, blockNumber) { return __awaiter(void 0, void 0, void 0, function () {
    var filter, newGasLogs, _i, newGasLogs_1, gasLog, _a, newGasLogs_2, gasLog, _b, newGasLogs_3, gasLog, _c, newGasLogs_4, gasLog;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                filter = from.gasReceiver.filters.GasPaidForContractCall();
                return [4 /*yield*/, from.gasReceiver.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 1:
                newGasLogs = (_d.sent()).map(function (log) { return log.args; });
                for (_i = 0, newGasLogs_1 = newGasLogs; _i < newGasLogs_1.length; _i++) {
                    gasLog = newGasLogs_1[_i];
                    exports.gasLogs.push(gasLog);
                }
                filter = from.gasReceiver.filters.NativeGasPaidForContractCall();
                return [4 /*yield*/, from.gasReceiver.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 2:
                newGasLogs = (_d.sent()).map(function (log) {
                    return __assign(__assign({}, log.args), { gasToken: AddressZero });
                });
                for (_a = 0, newGasLogs_2 = newGasLogs; _a < newGasLogs_2.length; _a++) {
                    gasLog = newGasLogs_2[_a];
                    exports.gasLogs.push(gasLog);
                }
                filter = from.gasReceiver.filters.GasPaidForContractCallWithToken();
                return [4 /*yield*/, from.gasReceiver.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 3:
                newGasLogs = (_d.sent()).map(function (log) { return log.args; });
                for (_b = 0, newGasLogs_3 = newGasLogs; _b < newGasLogs_3.length; _b++) {
                    gasLog = newGasLogs_3[_b];
                    exports.gasLogsWithToken.push(gasLog);
                }
                filter = from.gasReceiver.filters.NativeGasPaidForContractCallWithToken();
                return [4 /*yield*/, from.gasReceiver.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 4:
                newGasLogs = (_d.sent()).map(function (log) {
                    return __assign(__assign({}, log.args), { gasToken: AddressZero });
                });
                for (_c = 0, newGasLogs_4 = newGasLogs; _c < newGasLogs_4.length; _c++) {
                    gasLog = newGasLogs_4[_c];
                    exports.gasLogsWithToken.push(gasLog);
                }
                return [2 /*return*/];
        }
    });
}); };
var updateDepositAddresses = function (from, blockNumber, relayData, commands) { return __awaiter(void 0, void 0, void 0, function () {
    var _loop_1, _a, _b, _i, address;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _loop_1 = function (address) {
                    var data, tokenSymbol, token, fee, balance, to, destinationTokenSymbol, commandId, wallet, _d, tx;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                data = networkUtils_1.depositAddresses[from.name][address];
                                tokenSymbol = from.tokens[data.alias];
                                return [4 /*yield*/, from.getTokenContract(tokenSymbol)];
                            case 1:
                                token = _e.sent();
                                fee = (0, networkUtils_1.getFee)(from, data.destinationChain, data.alias);
                                return [4 /*yield*/, token.balanceOf(address)];
                            case 2:
                                balance = _e.sent();
                                to = Network_1.networks.find(function (chain) { return chain.name == data.destinationChain; });
                                destinationTokenSymbol = to.tokens[data.alias];
                                if (!(balance > fee)) return [3 /*break*/, 9];
                                commandId = (0, utils_1.getRandomID)();
                                relayData.depositAddress[commandId] = {
                                    from: from.name,
                                    to: data.destinationChain,
                                    amountIn: balance,
                                    fee: fee,
                                    amountOut: balance - fee,
                                };
                                commands[data.destinationChain].push(new Command(commandId, 'mintToken', [destinationTokenSymbol, data.destinationAddress, balance - fee], ['string', 'address', 'uint256']));
                                wallet = new ethers_1.Wallet(data.privateKey, from.provider);
                                _d = Number;
                                return [4 /*yield*/, from.provider.getBalance(address)];
                            case 3:
                                if (!(_d.apply(void 0, [_e.sent()]) == 0)) return [3 /*break*/, 6];
                                tx = {
                                    to: address,
                                    // Convert currency unit from ether to wei
                                    value: BigInt(1e16),
                                };
                                return [4 /*yield*/, from.ownerWallet.sendTransaction(tx)];
                            case 4: 
                            // Send a transaction
                            return [4 /*yield*/, (_e.sent()).wait()];
                            case 5:
                                // Send a transaction
                                _e.sent();
                                _e.label = 6;
                            case 6: return [4 /*yield*/, token.connect(wallet).transfer(from.ownerWallet.address, balance)];
                            case 7: return [4 /*yield*/, (_e.sent()).wait()];
                            case 8:
                                _e.sent();
                                _e.label = 9;
                            case 9: return [2 /*return*/];
                        }
                    });
                };
                _a = [];
                for (_b in networkUtils_1.depositAddresses[from.name])
                    _a.push(_b);
                _i = 0;
                _c.label = 1;
            case 1:
                if (!(_i < _a.length)) return [3 /*break*/, 4];
                address = _a[_i];
                return [5 /*yield**/, _loop_1(address)];
            case 2:
                _c.sent();
                _c.label = 3;
            case 3:
                _i++;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/];
        }
    });
}); };
var updateTokenSent = function (from, blockNumber, relayData, commands) { return __awaiter(void 0, void 0, void 0, function () {
    var filter, logsFrom, _loop_2, _i, logsFrom_1, log;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                filter = from.gateway.filters.TokenSent();
                return [4 /*yield*/, from.gateway.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 1:
                logsFrom = _a.sent();
                _loop_2 = function (log) {
                    var args = log.args;
                    var alias = getAliasFromSymbol(from.tokens, args.symbol);
                    var fee = (0, networkUtils_1.getFee)(from, args.destinationChain, alias);
                    if (args.amount <= fee)
                        return "continue";
                    var amountOut = args.amount.sub(fee);
                    var commandId = (0, utils_1.getLogID)(from.name, log);
                    var to = Network_1.networks.find(function (chain) { return chain.name == args.destinationChain; });
                    var destinationTokenSymbol = to.tokens[alias];
                    relayData.sendToken[commandId] = {
                        from: from.name,
                        to: args.destinationChain,
                        amountIn: args.amount,
                        fee: fee,
                        alias: alias,
                        amountOut: amountOut,
                    };
                    commands[args.destinationChain].push(new Command(commandId, 'mintToken', [destinationTokenSymbol, args.destinationAddress, amountOut], ['string', 'address', 'uint256']));
                };
                for (_i = 0, logsFrom_1 = logsFrom; _i < logsFrom_1.length; _i++) {
                    log = logsFrom_1[_i];
                    _loop_2(log);
                }
                return [2 /*return*/];
        }
    });
}); };
var updateCallContract = function (from, blockNumber, relayData, commands) { return __awaiter(void 0, void 0, void 0, function () {
    var filter, logsFrom, _loop_3, _i, logsFrom_2, log;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                filter = from.gateway.filters.ContractCall();
                return [4 /*yield*/, from.gateway.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 1:
                logsFrom = _a.sent();
                _loop_3 = function (log) {
                    var args = log.args;
                    if (commands[args.destinationChain] == null)
                        return "continue";
                    var commandId = (0, utils_1.getLogID)(from.name, log);
                    relayData.callContract[commandId] = {
                        from: from.name,
                        to: args.destinationChain,
                        sourceAddress: args.sender,
                        destinationContractAddress: args.destinationContractAddress,
                        payload: args.payload,
                        payloadHash: args.payloadHash,
                    };
                    commands[args.destinationChain].push(new Command(commandId, 'approveContractCall', [from.name, args.sender, args.destinationContractAddress, args.payloadHash], ['string', 'string', 'address', 'bytes32'], function (options) { return __awaiter(void 0, void 0, void 0, function () {
                        var to, contract, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    to = Network_1.networks.find(function (chain) { return chain.name == args.destinationChain; });
                                    contract = new ethers_1.Contract(args.destinationContractAddress, IAxelarExecutable.abi, to.relayerWallet);
                                    _a = relayData.callContract[commandId];
                                    return [4 /*yield*/, contract.execute(commandId, from.name, args.sender, args.payload, options)];
                                case 1: return [4 /*yield*/, (_b.sent()).wait()];
                                case 2:
                                    _a.execution = (_b.sent()).transactionHash;
                                    return [2 /*return*/];
                            }
                        });
                    }); }));
                };
                for (_i = 0, logsFrom_2 = logsFrom; _i < logsFrom_2.length; _i++) {
                    log = logsFrom_2[_i];
                    _loop_3(log);
                }
                return [2 /*return*/];
        }
    });
}); };
var updateCallContractWithToken = function (from, blockNumber, relayData, commands) { return __awaiter(void 0, void 0, void 0, function () {
    var filter, logsFrom, _loop_4, _i, logsFrom_3, log;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                filter = from.gateway.filters.ContractCallWithToken();
                return [4 /*yield*/, from.gateway.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber)];
            case 1:
                logsFrom = _a.sent();
                _loop_4 = function (log) {
                    var args = log.args;
                    var alias = getAliasFromSymbol(from.tokens, args.symbol);
                    var fee = (0, networkUtils_1.getFee)(from, args.destinationChain, alias);
                    if (args.amount < fee)
                        return "continue";
                    var amountOut = args.amount.sub(fee);
                    if (amountOut < 0)
                        return "continue";
                    var commandId = (0, utils_1.getLogID)(from.name, log);
                    var to = Network_1.networks.find(function (chain) { return chain.name == args.destinationChain; });
                    var destinationTokenSymbol = to.tokens[alias];
                    relayData.callContractWithToken[commandId] = {
                        from: from.name,
                        to: args.destinationChain,
                        sourceAddress: args.sender,
                        destinationContractAddress: args.destinationContractAddress,
                        payload: args.payload,
                        payloadHash: args.payloadHash,
                        alias: alias,
                        amountIn: args.amount,
                        fee: fee,
                        amountOut: amountOut,
                    };
                    commands[args.destinationChain].push(new Command(commandId, 'approveContractCallWithMint', [from.name, args.sender, args.destinationContractAddress, args.payloadHash, destinationTokenSymbol, amountOut], ['string', 'string', 'address', 'bytes32', 'string', 'uint256'], function (options) { return __awaiter(void 0, void 0, void 0, function () {
                        var to, contract, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    to = Network_1.networks.find(function (chain) { return chain.name == args.destinationChain; });
                                    contract = new ethers_1.Contract(args.destinationContractAddress, IAxelarExecutable.abi, to.relayerWallet);
                                    _a = relayData.callContractWithToken[commandId];
                                    return [4 /*yield*/, contract.executeWithToken(commandId, from.name, args.sender, args.payload, destinationTokenSymbol, amountOut, options)];
                                case 1: return [4 /*yield*/, (_b.sent()).wait()];
                                case 2:
                                    _a.execution = (_b.sent()).transactionHash;
                                    return [2 /*return*/];
                            }
                        });
                    }); }));
                };
                for (_i = 0, logsFrom_3 = logsFrom; _i < logsFrom_3.length; _i++) {
                    log = logsFrom_3[_i];
                    _loop_4(log);
                }
                return [2 /*return*/];
        }
    });
}); };
var executeCommands = function (to, commands) { return __awaiter(void 0, void 0, void 0, function () {
    var data, signedData;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                data = arrayify(defaultAbiCoder.encode(['uint256', 'uint256', 'bytes32[]', 'string[]', 'bytes[]'], [
                    to.chainId,
                    ROLE_OWNER,
                    commands.map(function (com) { return com.commandId; }),
                    commands.map(function (com) { return com.name; }),
                    commands.map(function (com) { return com.encodedData; }),
                ]));
                return [4 /*yield*/, (0, utils_1.getSignedExecuteInput)(data, to.operatorWallet)];
            case 1:
                signedData = _a.sent();
                return [4 /*yield*/, to.gateway.connect(to.ownerWallet).execute(signedData, { gasLimit: BigInt(1e7) })];
            case 2: return [4 /*yield*/, (_a.sent()).wait()];
            case 3: return [2 /*return*/, _a.sent()];
        }
    });
}); };
var postExecute = function (to, commands, execution) { return __awaiter(void 0, void 0, void 0, function () {
    var _loop_5, _i, commands_1, command;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _loop_5 = function (command) {
                    var fromName, from, payed, index, index, cost, blockLimit, _b, e_1;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                if (command.post == null)
                                    return [2 /*return*/, "continue"];
                                if (!execution.events.find(function (event) {
                                    return event.event == 'Executed' && event.args[0] == command.commandId;
                                }))
                                    return [2 /*return*/, "continue"];
                                fromName = command.data[0];
                                from = Network_1.networks.find(function (network) { return network.name == fromName; });
                                payed = command.name == 'approveContractCall'
                                    ? exports.gasLogs.find(function (log) {
                                        if (log.sourceAddress.toLowerCase() != command.data[1].toLowerCase())
                                            return false;
                                        if (log.destinationChain.toLowerCase() != to.name.toLowerCase())
                                            return false;
                                        if (log.destinationAddress.toLowerCase() != command.data[2].toLowerCase())
                                            return false;
                                        if (log.payloadHash.toLowerCase() != command.data[3].toLowerCase())
                                            return false;
                                        return true;
                                    })
                                    : exports.gasLogsWithToken.find(function (log) {
                                        if (log.sourceAddress.toLowerCase() != command.data[1].toLowerCase())
                                            return false;
                                        if (log.destinationChain.toLowerCase() != to.name.toLowerCase())
                                            return false;
                                        if (log.destinationAddress.toLowerCase() != command.data[2].toLowerCase())
                                            return false;
                                        if (log.payloadHash.toLowerCase() != command.data[3].toLowerCase())
                                            return false;
                                        var alias = getAliasFromSymbol(from.tokens, log.symbol);
                                        if (to.tokens[alias] != command.data[4])
                                            return false;
                                        if (log.amount - (0, networkUtils_1.getFee)(fromName, to, command.data[4]) != command.data[5])
                                            return false;
                                        return true;
                                    });
                                if (!payed)
                                    return [2 /*return*/, "continue"];
                                if (command.name == 'approveContractCall') {
                                    index = exports.gasLogs.indexOf(payed);
                                    exports.gasLogs.splice(index, 1);
                                }
                                else {
                                    index = exports.gasLogsWithToken.indexOf(payed);
                                    exports.gasLogsWithToken.splice(index, 1);
                                }
                                _c.label = 1;
                            case 1:
                                _c.trys.push([1, 4, , 5]);
                                cost = (0, networkUtils_1.getGasPrice)(fromName, to, payed.gasToken);
                                _b = Number;
                                return [4 /*yield*/, to.provider.getBlock('latest')];
                            case 2:
                                blockLimit = _b.apply(void 0, [(_c.sent()).gasLimit]);
                                return [4 /*yield*/, command.post({
                                        gasLimit: BigInt(Math.min(blockLimit, payed.gasFeeAmount / cost)),
                                    })];
                            case 3:
                                _c.sent();
                                return [3 /*break*/, 5];
                            case 4:
                                e_1 = _c.sent();
                                utils_1.logger.log(e_1);
                                return [3 /*break*/, 5];
                            case 5: return [2 /*return*/];
                        }
                    });
                };
                _i = 0, commands_1 = commands;
                _a.label = 1;
            case 1:
                if (!(_i < commands_1.length)) return [3 /*break*/, 4];
                command = commands_1[_i];
                return [5 /*yield**/, _loop_5(command)];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3:
                _i++;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/];
        }
    });
}); };
//This function relays all the messages between the tracked networks.
var relay = function () { return __awaiter(void 0, void 0, void 0, function () {
    var relayData, commands, _i, networks_1, to, _a, networks_2, from, blockNumber, _b, networks_3, to, toExecute, execution;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                relayData = {
                    depositAddress: {},
                    sendToken: {},
                    callContract: {},
                    callContractWithToken: {},
                };
                commands = {};
                for (_i = 0, networks_1 = Network_1.networks; _i < networks_1.length; _i++) {
                    to = networks_1[_i];
                    commands[to.name] = [];
                }
                _a = 0, networks_2 = Network_1.networks;
                _c.label = 1;
            case 1:
                if (!(_a < networks_2.length)) return [3 /*break*/, 9];
                from = networks_2[_a];
                return [4 /*yield*/, from.provider.getBlockNumber()];
            case 2:
                blockNumber = _c.sent();
                if (blockNumber <= from.lastRelayedBlock)
                    return [3 /*break*/, 8];
                return [4 /*yield*/, updateGasLogs(from, blockNumber)];
            case 3:
                _c.sent();
                return [4 /*yield*/, updateDepositAddresses(from, blockNumber, relayData, commands)];
            case 4:
                _c.sent();
                return [4 /*yield*/, updateTokenSent(from, blockNumber, relayData, commands)];
            case 5:
                _c.sent();
                return [4 /*yield*/, updateCallContract(from, blockNumber, relayData, commands)];
            case 6:
                _c.sent();
                return [4 /*yield*/, updateCallContractWithToken(from, blockNumber, relayData, commands)];
            case 7:
                _c.sent();
                from.lastRelayedBlock = blockNumber;
                _c.label = 8;
            case 8:
                _a++;
                return [3 /*break*/, 1];
            case 9:
                _b = 0, networks_3 = Network_1.networks;
                _c.label = 10;
            case 10:
                if (!(_b < networks_3.length)) return [3 /*break*/, 14];
                to = networks_3[_b];
                toExecute = commands[to.name];
                if (toExecute.length == 0)
                    return [3 /*break*/, 13];
                return [4 /*yield*/, executeCommands(to, toExecute)];
            case 11:
                execution = _c.sent();
                return [4 /*yield*/, postExecute(to, toExecute, execution)];
            case 12:
                _c.sent();
                _c.label = 13;
            case 13:
                _b++;
                return [3 /*break*/, 10];
            case 14: return [2 /*return*/, relayData];
        }
    });
}); };
exports.relay = relay;
//# sourceMappingURL=relay.js.map